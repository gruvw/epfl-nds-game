#include <nds.h>
#include <stddef.h>
#include <stdio.h>
#include "demo.h"
#include "nds/arm9/background.h"
#include "nds/arm9/video.h"
#include "nds/input.h"

/*** You may want to use follow variables in your solutions ***/
// Color definitions
#define	RED   ARGB16(1,31,0,0)
#define	BLUE  ARGB16(1,0,0,31)
#define	GREEN ARGB16(1,0,31,0)
#define	WHITE ARGB16(1,31,31,31)
#define	BLACK ARGB16(1,0,0,0)

#define TILE_OF(color) ((color) == RED ? 0 : ((color) == BLUE ? 1 : ((color) == GREEN ? 2 : ((color) == WHITE ? 3 : 4))))

// 5 custom color tiles
u8 RedTile[64] =
{
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0
};

u8 BlueTile[64] =
{
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1
};

u8 GreenTile[64] =
{
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2
};

u8 WhiteTile[64] =
{
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3
};

u8 BlackTile[64] =
{
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4
};


// rainbow_snake struct
typedef struct rainbow_snake{
	int tail_x;
	int tail_y;
	int tail_color;
	int body_x;
	int body_y;
	int body_color;
	int head_x;
	int head_y;
	int head_color;
} rainbow_snake;

// declare a snake struct
rainbow_snake snake;

// Direction definition
enum DIRECTION {
  LEFT,
  RIGHT,
  UP,
  DOWN
};
// initialize direction as RIGHT
enum DIRECTION direction = RIGHT;

void update_snake() {
    BG_MAP_RAM_SUB(0)[snake.tail_y * 32 + snake.tail_x] = TILE_OF(snake.tail_color);
    BG_MAP_RAM_SUB(0)[snake.body_y * 32 + snake.body_x] = TILE_OF(snake.body_color);
    BG_MAP_RAM_SUB(0)[snake.head_y * 32 + snake.head_x] = TILE_OF(snake.head_color);
}

/*** You may want to use the above variables in your solutions ***/

void timer_ISR()
{
	/*************
	 * EXERCISE 3 (part B)
	 *************/
	// 1) update the position of different parts of the snake, leave a white tile behind the tail
    BG_MAP_RAM_SUB(0)[snake.tail_y * 32 + snake.tail_x] = TILE_OF(WHITE);

    // Horizontal
    if (snake.head_x == 31 && direction == RIGHT) {
        direction = DOWN;
    }
    if (snake.body_x == 31 && direction == DOWN) {
        direction = LEFT;
    }
    if (snake.head_x == 0 && direction == LEFT) {
        direction = DOWN;
    }
    if (snake.body_x == 0 && direction == DOWN) {
        direction = RIGHT;
    }


    // Vertical
    if (snake.head_y == 0 && direction == UP) {
        direction = RIGHT;
    }
    if (snake.body_y == 0 && direction == RIGHT && snake.tail_y != snake.head_y) {
        direction = DOWN;
    }
    if (snake.head_y == 23 && direction == DOWN) {
        direction = RIGHT;
    }
    if (snake.body_y == 23 && direction == RIGHT && snake.tail_y != snake.head_y) {
        direction = UP;
    }

    snake.tail_x = snake.body_x;
    snake.tail_y = snake.body_y;
    snake.body_x = snake.head_x;
    snake.body_y = snake.head_y;
    snake.head_x += (direction == UP || direction == DOWN) ? 0 : (direction == RIGHT ? 1 : -1);
    snake.head_y += (direction == RIGHT || direction == LEFT) ? 0 : (direction == DOWN ? 1 : -1);

	// 2) generate a new map for the snake
    update_snake();
}


int main(void) {

	/*************
	 * EXERCISE 1
	 *************/

	// 1) VRAM Configuration for MAIN engine
    VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG;

	// 2) Main engine configuration in rotoscale mode
    REG_DISPCNT = MODE_5_2D | DISPLAY_BG2_ACTIVE;

	// 3) Configure the background (Ignore warning 'large implictly truncated to unsigned type')
    BGCTRL[2] = BG_BMP_BASE(0) | BgSize_B8_256x256;

	// 4) Copy bitmap and palette generated by grit
    swiCopy(demoBitmap, BG_BMP_RAM(0), demoBitmapLen/2);
    swiCopy(demoPal, BG_PALETTE, demoPalLen/2);

	// !!! Uncomment this for including the Affine Matrix Transformation (MAC and Native Linux user only!)
	bgTransform[2]->hdx = 1*256;
	bgTransform[2]->vdx = 0*256;
	bgTransform[2]->hdy = 0*256;
	bgTransform[2]->vdy = 1*256;
	bgTransform[2]->dx = 0*256;
	bgTransform[2]->dy = 0*256;

	/**************
	 * EXERCISE 2 *
	 **************/

	// 1) VRAM configuration for SUB engine
    VRAM_C_CR = VRAM_ENABLE | VRAM_C_SUB_BG;

	// 2) SUB engine configuration in tiled mode
    REG_DISPCNT_SUB = MODE_5_2D | DISPLAY_BG0_ACTIVE;

	// 3) Configure the background
    BGCTRL_SUB[0] = BG_32x32 | BG_COLOR_256 | BG_MAP_BASE(0) | BG_TILE_BASE(1);

	// 4) Copy the 5 tiles to the tile base
    swiCopy(RedTile, BG_TILE_RAM_SUB(1), 32);
    swiCopy(BlueTile, &BG_TILE_RAM_SUB(1)[1*32], 32);
    swiCopy(GreenTile, &BG_TILE_RAM_SUB(1)[2*32], 32);
    swiCopy(WhiteTile, &BG_TILE_RAM_SUB(1)[3*32], 32);
    swiCopy(BlackTile, &BG_TILE_RAM_SUB(1)[4*32], 32);

	// 5) Initialize the palette (5 components)
    BG_PALETTE_SUB[0] = RED;
    BG_PALETTE_SUB[1] = BLUE;
    BG_PALETTE_SUB[2] = GREEN;
    BG_PALETTE_SUB[3] = WHITE;
    BG_PALETTE_SUB[4] = BLACK;

	// 6) Generate the map for black background
    for (size_t col = 0; col < 32; ++col) {
        for (size_t row = 0; row < 24; ++row) {
            BG_MAP_RAM_SUB(0)[row * 32 + col] = 4;
        }
    }

	// 7) set the initial position of the snake, as well as the color of each part
    snake.tail_x = 0;
    snake.tail_y = 0;
    snake.body_x = 1;
    snake.body_y = 0;
    snake.head_x = 2;
    snake.head_y = 0;

    snake.tail_color = RED;
    snake.body_color = BLUE;
    snake.head_color = GREEN;

	// 8) Generate the map for the snake
    update_snake();


	/*************
	 * EXERCISE 3 (part A)
	 *************/
	///////////////////////////////////////////////////////////////////////////////////////
	//IMPORTANT NOTE!!!: Do not initialize the interrupts with the call to irqInit() since
	// later the touchscreen will be used
	///////////////////////////////////////////////////////////////////////////////////////

	// 1) Configure the timer to raise an interrupt 10 times per second
  	int frequency = 10;
    TIMER_DATA(0) = TIMER_FREQ_64(frequency);
    TIMER_CR(0) = TIMER_ENABLE | TIMER_DIV_64 | TIMER_IRQ_REQ;


	// 2) Associate the implemented ISR to the Timer Interrupt Line
    irqSet(IRQ_TIMER(0), &timer_ISR);

	// 3) Enable the timer interrupt
    irqEnable(IRQ_TIMER(0));

	// 4) Implement the functionality of the timer_ISR(), which is defined above main()

	scanKeys();
    while(1){

		/*************
		 * EXERCISE 4
		 *************/

    	// 1) Scan the keypad
        scanKeys();

    	// 2) Obtain the pressed keys
        uint32 keys = keysDown();

    	// 3) change the direction of the snake according to the pressed keys
        if ((keys & KEY_UP) != 0) {
            direction = UP;
        }
        if ((keys & KEY_DOWN) != 0) {
            direction = DOWN;
        }
        if ((keys & KEY_LEFT) != 0) {
            direction = LEFT;
        }
        if ((keys & KEY_RIGHT) != 0) {
            direction = RIGHT;
        }

		// 4) Complete the functionality about moving up and down of the snake in timer_ISR(), which is defined above main()

		/*************
		 * EXERCISE 5
		 *************/
    	// 1) If the touchscreen is touched, increase and set the new frequency. Note that the frequency should be no larger than 60
        if ((keys & KEY_TOUCH) != 0) {
            frequency *= 2;
            if (frequency > 60) {
                frequency = 10;
            }
            TIMER_DATA(0) = TIMER_FREQ_64(frequency);
        }


        swiWaitForVBlank();
    }
}
