#include <nds.h>
#include <stdio.h>
#include "logo.h"
#include "nds/arm9/background.h"
#include "nds/arm9/input.h"
#include "nds/arm9/video.h"
#include "nds/bios.h"
#include "nds/input.h"
#include "nds/timers.h"

#define	RED   ARGB16(1,31,0,0)
#define	GREEN ARGB16(1,0,31,0)
#define	BLUE  ARGB16(1,0,0,31)
#define	WHITE ARGB16(1,31,31,31)
#define	BLACK ARGB16(1,0,0,0)


//Timer ISR (for EXERCISE 3)
// You may want to use these variables in your ISR
int current_color = 0, timer_row = 0, timer_column = 0;
void timer_ISR()
{
    BG_MAP_RAM_SUB(0)[timer_row * 32 + timer_column] = current_color;

    timer_column = (timer_column + 2) % 32;

    if (timer_column == 0 || timer_column == 1) {
        timer_row = (timer_row + 1) % 24;
        timer_column = timer_column == 0 ? 1 : 0;
    }

    if (timer_row == timer_column && timer_column == 0) {
        current_color = (current_color + 1) % 3;
    }
}

// Different color tiles
u8 RedTile[64] =
{
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0
};

u8 GreenTile[64] =
{
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1
};

u8 BlueTile[64] =
{
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2
};

u8 WhiteTile[64] =
{
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3
};

u8 BlackTile[64] =
{
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4
};



int main(void) {

	/*************
	 * EXERCISE 1
	 *************/
	// 1) VRAM configuration for SUB engine
    VRAM_C_CR = VRAM_ENABLE | VRAM_C_SUB_BG;

	// 2) SUB engine configuration in tiled mode
    REG_DISPCNT_SUB = MODE_3_2D | DISPLAY_BG0_ACTIVE;

	// 3) Configure the background
    BGCTRL_SUB[0] = BG_32x32 | BG_COLOR_256 | BG_MAP_BASE(0) | BG_TILE_BASE(1);

	// 4) Copy the 4 tiles to the tile base
    swiCopy(RedTile, BG_TILE_RAM_SUB(1), 32);
    swiCopy(GreenTile, &BG_TILE_RAM_SUB(1)[32], 32);
    swiCopy(BlueTile, &BG_TILE_RAM_SUB(1)[2*32], 32);
    swiCopy(WhiteTile, &BG_TILE_RAM_SUB(1)[3*32], 32);
    swiCopy(BlackTile, &BG_TILE_RAM_SUB(1)[4*32], 32);

    // 5) Initialize the palette (5 components)
    BG_PALETTE_SUB[0] = RED;
    BG_PALETTE_SUB[1] = GREEN;
    BG_PALETTE_SUB[2] = BLUE;
    BG_PALETTE_SUB[3] = WHITE;
    BG_PALETTE_SUB[4] = BLACK;

    // 6) Generate the map
    for (size_t col = 0; col < 32; col++) {
        for (size_t row = 0; row < 24; row++) {
            BG_MAP_RAM_SUB(0)[row * 32 + col] = (col+row) % 2 == 0 ? 3 : 4;
        }

    }

    /*************
	 * EXERCISE 2
	 *************/

    // 1) VRAM Configuration for MAIN engine
    VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG;

    // 2) Main engine configuration in rotoscale mode
    REG_DISPCNT = MODE_5_2D | DISPLAY_BG2_ACTIVE;

    // 3) Configure the background
    BGCTRL[2] = BG_BMP_BASE(0) | BgSize_B8_256x256;

    // 4) Copy bitmap and palette generated by grit
    swiCopy(logoBitmap, BG_BMP_RAM(0), logoBitmapLen/2);
    swiCopy(logoPal, BG_PALETTE, logoPalLen/2);

    // Uncomment this for including the Affine Marix Transformation
    bgTransform[2]->hdx = 1*256;
    bgTransform[2]->vdx = 0*256;
    bgTransform[2]->hdy = 0*256;
    bgTransform[2]->vdy = 1*256;
    bgTransform[2]->dx = 0*256;
    bgTransform[2]->dy = 0*256;

    // Uncomment this for including the Affine Marix Transformation (MAC only!)
    //	bgTransform[2]->hdx = 1*256;
    //	bgTransform[2]->vdx = 0*256;
    //	bgTransform[2]->hdy = 0*256;
    //	bgTransform[2]->vdy = 1*256;
    //	bgTransform[2]->dx = 0*256;
    //	bgTransform[2]->dy = 0*256;

    /*************
	 * EXERCISE 3
	 *************/
    ///////////////////////////////////////////////////////////////////////////////////////
    //Note: Do not initialize the interrupts with the call to irqInit()
    // since later the touchscreen will be used
    ///////////////////////////////////////////////////////////////////////////////////////

    // 1) Configure the timer to raise an interrupt 10 times per second
    int frequency = 20;
    TIMER_DATA(0) = TIMER_FREQ_64(frequency);
    TIMER_CR(0) = TIMER_ENABLE | TIMER_DIV_64 | TIMER_IRQ_REQ;

    // 2) Associate the implemented ISR to the Timer Interrupt Line
    irqSet(IRQ_TIMER(0), &timer_ISR);

    // 3) Enable the timer interrupt
    irqEnable(IRQ_TIMER(0));

    // 4) Implement the functionality of the timer ISR

    /*************
	 * EXERCISE 4
	 *************/
    while(1){

    	// 1) Scan the keypad
        scanKeys();

    	// 2) Obtain the pressed keys
        uint32 keys = keysDown();

    	// 3) Check if the pressed key is the correct one and increase/decrease the frequency accordingly
        if ((keys & KEY_UP) != 0) {
            frequency = frequency * 2;
            TIMER_DATA(0) = TIMER_FREQ_64(frequency);
        }
        if ((keys & KEY_DOWN) != 0) {
            frequency = (frequency / 2) | 1;
            TIMER_DATA(0) = TIMER_FREQ_64(frequency);
        }

    	// 4) Read the touchscreen position

    	// 4) If touched, set the new color
        if (keys & KEY_TOUCH) {
            current_color = (current_color + 1) % 3;
        }

        swiWaitForVBlank();
    }
}
